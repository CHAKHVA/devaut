import logging
from typing import List, Optional

from fastapi import HTTPException, status
from sqlmodel import Session

from app.crud import quiz_crud
from app.models.quiz_models import DifficultyLevel, Question, QuestionType
from app.schemas.quiz_schemas import (
    AnswerCreate,
    JobDescriptionCreate,
    JobDescriptionRead,
    MatchedQuizInfo,
    QuestionCreate,
)
from app.utils import ai_integration

logger = logging.getLogger(__name__)


def _calculate_time_limit(difficulty: DifficultyLevel) -> int:
    if difficulty == DifficultyLevel.EASY:
        return 10 * 60
    elif difficulty == DifficultyLevel.MEDIUM:
        return 20 * 60
    elif difficulty == DifficultyLevel.HARD:
        return 30 * 60
    else:
        return 15 * 60


async def generate_quiz_for_jd(db: Session, jd_text: str) -> JobDescriptionRead:
    logger.info("Starting quiz generation process for new Job Description.")

    try:
        jd_create_schema = JobDescriptionCreate(original_text=jd_text)
        db_jd = quiz_crud.create_job_description(db=db, jd_in=jd_create_schema)
        logger.info(f"Created JobDescription record with ID: {db_jd.id}")
    except Exception as e:
        logger.error(f"Failed to create JobDescription record: {e}", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to save job description.",
        )

    existing_quiz = quiz_crud.get_quiz_by_jd_id(db=db, jd_id=db_jd.id)
    if existing_quiz:
        logger.warning(
            f"Quiz already exists for JobDescription ID: {db_jd.id}. Returning existing data."
        )
        db.refresh(db_jd, attribute_names=["generated_quiz"])
        return JobDescriptionRead.model_validate(db_jd)

    logger.info(f"Processing Job Description ID: {db_jd.id} with AI...")
    ai_result = ai_integration.process_jd_with_ai(job_description_text=jd_text)

    if not ai_result:
        logger.error(f"AI processing failed for Job Description ID: {db_jd.id}.")
        raise HTTPException(
            status_code=status.HTTP_502_BAD_GATEWAY,  # Or 500
            detail="AI service failed to process the job description.",
        )
    logger.info(f"AI processing successful for Job Description ID: {db_jd.id}.")

    created_questions: List[Question] = []
    try:
        ai_questions = ai_result.get("questions", [])
        if not ai_questions:
            logger.warning(
                f"AI did not return any questions for JD ID: {db_jd.id}. Creating quiz without questions."
            )

        for q_data in ai_questions:
            answers_create = [
                AnswerCreate.model_validate(ans_data)
                for ans_data in q_data.get("answers", [])
            ]
            question_create = QuestionCreate(
                text=q_data.get("text", "Missing question text"),
                question_type=q_data.get("question_type", QuestionType.SINGLE_CHOICE),
                difficulty=q_data.get("difficulty", DifficultyLevel.MEDIUM),
                answers=answers_create,
            )
            db_question = quiz_crud.create_question(db=db, question_in=question_create)
            created_questions.append(db_question)
        logger.info(
            f"Created {len(created_questions)} questions for JD ID: {db_jd.id}."
        )

    except Exception as e:
        logger.error(
            f"Failed to create questions/answers from AI data for JD ID: {db_jd.id}: {e}",
            exc_info=True,
        )
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to save questions generated by AI.",
        )

    quiz_difficulty = ai_result.get("difficulty", DifficultyLevel.MEDIUM)  # Use default
    time_limit = _calculate_time_limit(quiz_difficulty)

    try:
        db_quiz = quiz_crud.create_quiz_linked_to_jd(
            db=db,
            source_jd=db_jd,
            title=ai_result.get("title", f"Quiz for Job ID {db_jd.id}"),
            description=ai_result.get("description"),
            difficulty=quiz_difficulty,
            time_limit_seconds=time_limit,
            tags=ai_result.get("tags", []),
            questions=created_questions,
        )
        logger.info(
            f"Successfully created Quiz ID: {db_quiz.id} linked to JD ID: {db_jd.id}."
        )

        db.refresh(db_jd, attribute_names=["generated_quiz"])

        return JobDescriptionRead.model_validate(db_jd)

    except ValueError as ve:
        logger.warning(
            f"Attempted to create duplicate quiz link for JD ID: {db_jd.id}: {ve}"
        )
        db.refresh(db_jd, attribute_names=["generated_quiz"])
        return JobDescriptionRead.model_validate(db_jd)
    except Exception as e:
        logger.error(
            f"Failed to create and link Quiz for JD ID: {db_jd.id}: {e}", exc_info=True
        )
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to save the generated quiz.",
        )


async def find_matching_quizzes(
    db: Session,
    jd_text: Optional[str] = None,
    tags: Optional[List[str]] = None,
    limit: int = 10,
) -> List[MatchedQuizInfo]:
    target_tags: Optional[List[str]] = tags

    if not target_tags and jd_text:
        logger.info(
            "No tags provided, attempting to extract tags from JD text using AI..."
        )
        target_tags = ai_integration.extract_tags_with_ai(jd_text)
        if not target_tags:
            logger.warning("AI failed to extract tags from the provided text.")
            return []
        logger.info(f"AI extracted tags: {target_tags}")

    if not target_tags:
        logger.info("No tags found or provided to match.")
        return []

    try:
        matched_db_quizzes = quiz_crud.get_quizzes_by_tags(
            db=db, tags_to_match=target_tags, require_all=False, limit=limit
        )
    except NotImplementedError:
        logger.error(
            "Tag matching query is not implemented correctly in quiz_crud.get_quizzes_by_tags"
        )
        raise HTTPException(
            status_code=501, detail="Quiz matching by tags is not fully implemented."
        )
    except Exception as e:
        logger.error(f"Database error during tag matching: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail="Failed to query quizzes by tags.")

    results: List[MatchedQuizInfo] = []
    for quiz in matched_db_quizzes:
        score = 0.0
        if quiz.tags:
            common_tags = set(tag.lower() for tag in target_tags) & set(
                tag.lower() for tag in quiz.tags
            )
            union_tags = set(tag.lower() for tag in target_tags) | set(
                tag.lower() for tag in quiz.tags
            )
            if union_tags:
                score = len(common_tags) / len(union_tags)

        results.append(
            MatchedQuizInfo(
                id=quiz.id,
                title=quiz.title,
                description=quiz.description,
                difficulty=quiz.difficulty,
                created_at=quiz.created_at,
                tags=quiz.tags,
                match_score=round(score, 3),
            )
        )

    results.sort(key=lambda x: x.match_score, reverse=True)

    logger.info(f"Found {len(results)} matching quizzes for tags: {target_tags}")
    return results
